// Copyright Â© 2022 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

import (
	log "github.com/sirupsen/logrus"

	"github.com/cisco-open/kubei/api/server/models"
	_types "github.com/cisco-open/kubei/runtime_scan/pkg/types"
)

type ApplicationVulnerabilityScan struct {

	// resources
	Resources []*ResourceVulnerabilityScan `json:"resources"`
}

func ApplicationVulnerabilityScanFromRuntimeScan(scanResults []*_types.ImageScanResult) *ApplicationVulnerabilityScan {
	ret := &ApplicationVulnerabilityScan{}
	// Make sure we only append a resource once,
	// as an application can consist of multiple pods that share the same images.
	resourceHashMap := make(map[string]bool)

	for _, result := range scanResults {
		if resourceHashMap[result.ImageHash] {
			log.Debugf("Image hash %q already added - skipping. name=%v", result.ImageHash, result.ImageName)
			continue
		}
		// Only append resource once.
		resourceHashMap[result.ImageHash] = true
		ret.Resources = append(ret.Resources, &ResourceVulnerabilityScan{
			PackageVulnerabilities:    PackageVulnerabilitiesFromRuntimeScan(result.Vulnerabilities),
			CisDockerBenchmarkResults: CISDockerBenchmarkResultsFromFromRuntimeScan(result.CISDockerBenchmarkResult),
			Resource: &ResourceInfo{
				ResourceHash: result.ImageHash,
				ResourceName: result.ImageName,
				ResourceType: ResourceTypeIMAGE,
			},
		})
	}

	return ret
}

func ApplicationVulnerabilityScanFromBackendAPI(in *models.ApplicationVulnerabilityScan) *ApplicationVulnerabilityScan {
	ret := &ApplicationVulnerabilityScan{}

	for _, resource := range in.Resources {
		ret.Resources = append(ret.Resources, &ResourceVulnerabilityScan{
			PackageVulnerabilities:    PackageVulnerabilitiesScanFromBackendAPI(resource.PackageVulnerabilities),
			CisDockerBenchmarkResults: CISDockerBenchmarkResultsFromBackendAPI(resource.CisDockerBenchmarkResults),
			Resource:                  ResourceInfoFromBackendAPI(resource.Resource),
		})
	}

	return ret
}
